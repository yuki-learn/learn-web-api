
# 3章 レスポンスデータの設計

## 3.1 データフォーマット
Web APIではJSONとXMLがよく採用されるが、現在のデファクトスタンダードは**JSON**。<br>
JSONのほうがシンプルでデータ量が少なく、JavaScriptと相性がいい。

もし、JSONやXMLどちらも対応するのであれば、データフォーマットの指定は、**クエリパラメータ**で指定する方法が一番採用されている。

例
```
https://api.example.com/v1/users?format=xml

https://api.example.com/v1/users?format=json
```

## 3.3 データの内部構造の考え方
フォーマットを決めたら、実際にどんな構造のデータを返すようにするかを決める。

APIで返すレスポンスデータを決定する際はまず、**APIのアクセス回数をなるべく減るようにすること**を考えるべき。

SNSで友人一覧を返すAPIを想定したとき、そのAPIが以下のような友人IDの配列を返すだけだった場合、クライアントはこれを使って更に、別のAPIを呼び出して友人情報を取得することになる。
```json
{
    "friends": [
        1111,
        2222,
        3333
    ]
}
```

最低2回はアクセスしないと友人情報を取得できない使い勝手が悪いAPIとなるので、以下のようにユーザー情報が入ったリストを返したほうが良い。

```json
{
    "friends": [
        {
            "id": 1111,
            "name": "Taro Tanaka",
            "age": 20,
            ...
        },
        {
            "id": 2222,
            "name": "Hanako Yamada",
            "age": 23,
            ...
        },
    ]
}
```

友人関係を表すテーブルだった場合、こういったIDのみを返してしまいがちだが、**Web APIは単なるDBのアクセスインターフェースではなく、アプリケーションのインターフェースなので、そのアプリケーションの特性を踏まえた上で利用者が使いやすい構造にするべき**。<br>
1つの作業を完結するために複数回アクセスが必要な「**Chatty(おしゃべりな)API**」にはしなこと。


### レスポンスの内容をユーザーが選べるようにする
APIでできる限り多くのデータを返そうとすると、データ量が多くなってしまい、パフォーマンスの点で、使い勝手が悪くなる。返すデータをこちらで限定するにしても、利用者側のユースケースによって返すデータを決めるのが難しいため、**ユーザーが取得できる項目を選べるようにするのが良い**。

```
「fileds」というクエリパラメータで項目を指定できるAPI

http://api.example.com/v1/users/12345?fields=name,age
```

### エンベロープ
```json
{
    "header": {
        "status": "success",
        "errorCode": 0,
    },
    "response": {
        ... 実際のデータ ...
    }
}
```

headerとresponseという2つのデータを持つ構造をして、実際のデータにはresponseに、headerにはstatusやerrorCodeといったAPIに共通したメタデータが入っている。<br>
こうしたメタデータを含む形ですべてのAPIが同じデータ構造を返すために実際のデータを包むための構造を**エンベロープ**という。

便利なエンベロープだが、**冗長な表現のため、やるべきではない。**<br>
Web APIはHTTPを使用しているので、HTTPがエンベロープの役割をしている。(ヘッダーや、ステータスコード)<br>
**実際のデータはHTTPレスポンスボディで返し、メタデータはHTTPレスポンスヘッダで返せば良い。**


### データはフラットにすべきか


階層的にしたとき

```json
{
    "id": 3342124,
    "message": "Hi!",
    "sender": {
        "id": 3456,
        "name": "Taro Yamada"
    },
    "receiver": {
        "id": 12912,
        "name": "Kenji Suzuki"
    },
}
```

フラットにしたとき
```json
{
    "id": 3342124,
    "message": "Hi!",
    "sender_id": 3456,
    "sender_name": "Taro Yamada",
    "receiver_id": 12912,
    "receiver_name": "Kenji Suzuki",
}
```

GoogleのJSON Style Guidでは「なるべくフラットにしたほうが良いが、階層構造のほうがわかりやすいときもある」という曖昧な表記になっていて、状況次第で使い分ける必要がある。<br>
ただ、以下の`profile`のように単に複数項目をまとめたいためだけに階層構造は使用してもメリットがない。<br>
Googleのスタイル通り、**なるべくフラットにして、階層構造のほうが絶対にいいときは階層化を使う**。というルールが良い。
```json
    "id": 3342124,
    "message": "Taro Yamada",
    "profile": {
        "birthday": 3456,
        "gender": "male",
        "languages": ["ja", "en"]
    }
```

### 配列とフォーマット
配列をそのまま返すか、レスポンス全体をオブジェクトにしてその中に配列を入れるか。

配列をそのまま返す
```json
[
    {
        "id": 234342,
        "name": "Taro Tanaka",
        "profileIcon": "http://image.example.com/profile/234342.png",
        ...
        ...
    },
    {
        "id": 93734,
        "name": "Hanako Yamada",
        "profileIcon": "http://image.example.com/profile/93734.png",
        ...
        ...
    },
]
```

`friends`というオブジェクトで包む
```json
{
    "friends": [
        {
            "id": 234342,
            "name": "Taro Tanaka",
            "profileIcon": "http://image.example.com/profile/234342.png",
            ...
            ...
        },
        {
            "id": 93734,
            "name": "Hanako Yamada",
            "profileIcon": "http://image.example.com/profile/93734.png",
            ...
            ...
        },
    ]
}
```

どちらを選んでも問題ないが、どちらかと言えば、以下の点でオブジェクトで包むほうが良かったりする。
* レスポンスデータが何を示しているものかわかりやすくなる
    * `friends`というキーがついてるので、「友人の情報」ということがレスポンスからひと目でわかる。
* レスポンスデータをオブジェクトに統一することができる
    * トップレベルが直接配列だったり、オブジェクトだったりとAPIによって異なると、クライアント側で使いにくくなる可能性がある。
* セキュリティ上のリスクを避けることができる
    * トップレベルが配列であるJSONは、**JSONインジェクション**のリスクが大きくなりやすくなる。

## 3.4 各データのフォーマット

### 性別のデータをどう表すか
**フィールド名は「gender」を使用して、`male`、`female`といった文字列で表すのが良い。**

`male`や`female`というように文字列で表す方法と、1なら男性、2なら女性という数値に置き換えて表す方法があるが主要なサービスでは前者がよく使われている。<br>

主要なサービスのAPIで、フィールド名が`sex`の場合は、数値が使われたりするが、フィールド名が`gender`の場合は必ず文字列が使われる。理由として、`sex`は「生物学的な性別」を意味するので、入るものがあまり種類が多くないのに対し、`gender`は「社会的・文化的性別」を表すので、多くの種類が考えられるから。

### 日付のフォーマット

日付のよくあるフォーマット

| 形式名  |  例  |
| ---- | ---- |
|  RFC 822 (RFC 1123で修正)  |  Sun, 06 Nov 1994 08:49:37 GMT  |
|  RFC 850 (RFC 1036で廃止)  |  Sunday, 06-Nov-94 08:49:37 GMT  |
|  ANSI Cのasctime()形式  | Sun Nov 6 08:49:37 1994|
|  RFC 3339 | 2015-10-12T11:30:22+09:00|
|  Unix タイムスタンプ(epoch秒) | 1396821803 |

基本的に、**RFC 3339**を採用し、タイムゾーンは"+00:00"を使う。<br>
Unixタイムスタンプは数値なので比較や保持が楽だが、ぱっとみで時間がわかりにくく、開発等で手間が増える。

* "Jan"や"Fri"などの特定言語に依存した記述がない
* 日本語のように、年月日の順での表すので理解しやすい
* HTTPヘッダで用いられるHTTP時間はUTCが採用されているから"+00:00"がいい

### 大きな整数とJSON
Web APIで数値を返すときは、intの32ビットだと足りないので**longの64ビットを使って表す。**(実際にTwitterは32ビット領域を超えていて、64ビットを採用)

ただ、64ビットの大きな数値だと場合によってはクライアント側で桁あふれなどの不具合が出る可能性があるため、そのままJSONで数値を返すと問題になるときがある。<br>
Twitterのように、数値で返すものと、文字列で返すものを用意しておくと良い。

```json
{
    "id": 266031293949698048,
    "id_str": "266031293949698048",
}
```

## エラーの表現

### ステータスコードでエラーを表現する
Web APIでエラーを返す際は、ステータスコードを適切に使う。

| ステータスコード  |  意味  |
| ---- | ---- |
|  100番台  |  情報  |
|  200番台  |  成功  |
|  300番台  |  リダイレクト  |
|  400番台  |  クライアントサイドに起因するエラー  |
|  500番台  |  サーバサイドに起因するエラー  |

200番台はクライアントからのリクエストが成功した場合しか返してはならない。<br>
パラメータが間違っていたり、権限がなかったりしてエラーになった場合、エラーが返ってくるにも関わらず、ステータスコード200を返すケースがあるが、使い方として正しくない。

HTTPクライアントライブラリなどは、ステータスコードでリクエストが成功したかどうかを判断しているものが多いので、ステータスコードを正しく返さないと、利用者側で処理の手間が増えてしまう。


### エラーの詳細をクライアントに返す
エラーはステータスコードだけでは不十分。<br>
エラーの詳細がないと`404 Not Found`だった場合も指定したデータそのものがなかったのか、エンドポイントを間違えたのか、利用者は何を直せばいいのかがわからないので正しく、詳細も返す必要がある。

エラーの内容を返す方法は大きく2つあり、**HTTPレスポンスヘッダに入れる方法**と、**レスポンスボディで返す方法**がある。


HTTPレスポンスヘッダに入れる方法
```
X-MYNAME-ERROR-CODE: 2022
X-MYNAME-ERROR-MESSAGE: Bad authentication token
X-MYNAME-ERROR-INFO: http://docs.example.com/api/v1/authentication
```

レスポンスボディで返す方法
```json
{
    "error": {
        "code": 2022,
        "message": "Bad authentication token",
        "info": "http://docs.example.com/api/v1/authentication"
    }
}
```

クライアント側から見たときの利便性を考えるとレスポンスボディのほうが処理しやすいのと、公開されている主要なAPIはほとんどレスポンスボディで返しているので、レスポンスボディを使う方法のほうが良い。


### エラー詳細情報に入れる項目
最低限、エラーの詳細コード、詳細情報へのリンクなどがあれば良い。<br>
メッセージは、クライアントアプリケーションがユーザーにそのまま表示できるような、非開発者向けのメッセージと、原因を調べられる開発者向けのメッセージの両方を含める方法もある。

### メンテナンスとステータスコード
Web APIは常に稼働していることが望ましく、極力、停止することは避けるべきだが、どうしても停止してメンテナンスしなければならない場合は、**ステータスコードとして503を返し、現在サービスが停止していることを伝える必要がある。**

メンテナンスの終了時間が分かっている場合は、**Retry-After**というHTTPヘッダを使って、いつ終わるかを示す。Retry-Afterは「次はいつアクセスしてください」ということを表すためのヘッダ。

```
503 Service Temporarily Unavilable
Retry-After: Mon, 2 Dec 2022 03:00:00 GMT
```