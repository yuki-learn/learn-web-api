# 6章 堅牢なWeb APIを作る


## ブラウザでアクセスするAPIにおける問題
最も広く普及したブラウザからの不正アクセスや攻撃に対して注意を払う必要がある。

### XSS
XSSといえばHTMLにデータが埋め込まれている場合が想定されるが、APIとしてJSONを返すような場合でも同様の問題に注意する必要がある。

例えば、ユーザー名に埋め込まれたJavaScriptが入力のチェックをすり抜けてJSONにも格納されてしまった場合、それを受け取ったブラウザがそのまま画面上に表示し、JavaScriptが実行される恐れがある。

対策
* `Content-Type`に正しく`application/json`を指定してJSONとして解釈させる。
* `X-Content-Type-Options: nosniff`ヘッダを指定して、JavaScriptとして実行可能なメディアタイプを限定する。

### XSRF

* サーバ側のデータが変更するようなアクセスに関してはGETメソッドを使わない(そもそもAPIとしてよろしくない)

## 悪意のあるアクセスへの対策

### パラメータの改ざん

サーバに送信するパラメータを勝手に変更して送信することで、本来取得できない情報やサーバ側のデータを勝手に変更したりする不正アクセス。

以下のようなユーザーID`12345`の情報を取得できるAPIがあったとする。<br>
1は正常だが、2のようにユーザーIDを変更し、`email`はAPIドキュメントで公開されていないけど、メールアドレスが取得できるパラメータとして実装されていたら簡単に他人のメールアドレスが取得できてしまう。

```
1: https://api.example.com/v1/users/12345?fields=name

2: https://api.example.com/v1/users/12346?fields=email
```

こうしたことを避けるためにサーバ側では本来アクセスできない情報はサーバ側できちんとチェックしアクセスを禁止するようにしなければならない。



### リクエストの再送信
一度送ったリクエストを再度送信することで同じ処理をサーバ側にもう1度実行させてしまうこと。

ゲームのAPIで「敵に勝利した」ことを2回送って、報酬を2回もらえてしまったり、ECサイトでクーポンを何回でも使えてしまったりするようなこと。

ゲームであれば、戦闘の開始から終わりの状態を管理するようにしたり、ECサイトはクーポンを受け取ったかの情報を管理するように実装しなければならない。


## 大量アクセスへの対策
1度に大量のアクセスがやってきてしまう問題を解決する最も現実的な方法は、ユーザーがごとにアクセス数を制限すること。単位時間あたりの最大アクセス回数を制限する**レートリミット**を実装するのが良い。

例えば、1分間に60回のアクセス制限をしていたら61回目にはエラーを返すようにし、1分経過したら元通りにアクセスできるようにする。

### レートリミットの単位
* **単位時間は15分〜1時間にする**。1日だと一度アクセス頻度を間違えて制限にかかると24時間近くアクセスできないのは長すぎるため。
* すべてのエンドポイントでまとめて同じ制限にするか、エンドポイント別に制限を分けるかはサービスによって考える必要がある。あまり細かくするとサーバ側で多くの情報を管理しないといけないし、すべてひとくくりにするのも利便性が下がる。

### 制限値を超えてしまった場合の対応
制限値を超えてしまったときはそれ専用の **「429 Too Many Requests」** をサーバ側から返す。

`429`を返す際は、エラーの詳細をレスポンスに含め、`Retry-After`ヘッダを使って「次のリクエストを遅れるようになるまでどれくらい待てば良いか」の情報を返すと良い。


## Web APIチェックリスト
* URIが短く入力しやすくなっているか
* URIが人間が読んで理解できるようになっているか
* URIが小文字のみで構成されているか
* URIが改造しやすくなっているか
* URIにサーバ側のアーキテクチャが反映されていないか
* URIのルールは統一されているか
* 適切なHTTPメソッドを利用しているか
* URIで利用する単語は多くのAPIで同じ意味に利用されているものを選んでいるか
* URIで使われている名詞は複数形になっているか
* URI中にスペースやエンコードを必要とする文字が入っていないか
* URI中の単語はハイフンでつないでいるか
* ページネーションは適切に設計されているか
* ログインにはOAuth2.0を利用しているか
* レスポンスのデータ形式はJSONがデフォルトになっているか
* データ形式の指定にはクエリパラメータを使う方法をサポートしているか
* レスポンスのデータ内容はクライアントから指定できるようになっているか
* レスポンスデータに不要なエンベロープが入っていないか
* レスポンスデータの構造は可能なかぎりフラットになっているか
* レスポンスデータが配列ではなくオブジェクトになっているか
* レスポンスのデータ名として多くのAPIで同じ意味に利用されている一般的な単語を選んでいるか
* レスポンスのデータ名はなるべく少ない単語数で表現しているか
* レスポンスのデータ名として複数の単語を連結する場合、その連結方法はAPI全体を通して統一してあるか
* レスポンスのデータ名として変な省略形を使用していないか
* レスポンスのデータ名の単数形/複数形はデータの内容と合っているか
* エラー時のレスポンスはクライアントが原因を切り分けられるような情報を含んでいるか
* エラーの際にHTMLを返していないか
* 適切なステータスコードが返るようになっているか
* メンテンナス時には503を返すようになっているか
* 適切なメディアタイプを返しているか
* 必要な場合はCORSに対応しているか
* クライアントが適切にキャッシュを行えるように`Cache-Control`, `ETag`, `Last-Modified`, `Vary`などのレスポンスヘッダを返しているか
* キャッシュさせたくないデータには`Cache-Control: no-cache`が付けられているか
* APIはバージョンで管理されているか
* APIのバージョンはセマンティックバージョニングに沿ったものになっているか
* メジャーバージョン番号がURIに入っており、ひと目でわかるようになっているか
* APIの提供を終了する際のことを考慮してあるか
* APIの最低提供期間をドキュメントに明記してあるか
* HTTPSでAPIを提供しているか
* ブラウザからアクセスさせるAPIではXSRFトークンを利用しているか
* APIが受け取るパラメータはきちんと不正値をチェックしているか
* リクエストが再送信されてもデータを再度更新してしまわないようになっているか
* レスポンスにセキュリティ対策用の各種ヘッダをきちんと付けているか
* レートリミットによる制限を行っているか
* レートリミットの制限回数は想定されるユースケースに対して少なすぎないか