
# 2章 エンドポイントの設計とリクエストの形式

## 2.1 APIとして公開する機能を設計する

APIとして公開する機能を考えるときは、**公開したAPIがどのように使われるのか、ユースケースをきちんと考える**。


### SNSのモバイルアプリケーション向けのAPIを例にして考える
SNSアプリを例にAPIの機能を列挙すると以下のような機能がある

* ユーザー登録
* ログイン
* 自分の情報の取得
* 自分の情報の更新
* ユーザー情報の取得
* ユーザーの検索
* 友達の一覧の取得
* 友達の検索
* 友達の追加
* 友達の削除
* メッセージの投稿
* メッセージの編集
* メッセージの削除

これをすべてAPIにするのではなく、ここからまとめられるものなど整理していく。



## 2.2 APIエンドポイントの考え方
提供する機能を決めたらエンドポイントを考えながらAPIを整理していく。
Web APIにおける**エンドポイント**とは**APIにアクセスするためのURI**を意味する。

APIは通常、様々な機能がセットになっているので複数のエンドポイントが存在する。ECサイトであれば、商品情報を取得する機能や商品を購入する機能がそれぞれにエンドポイント、つまりAPIとしてアクセスするためのURIを持っている。

SNSアプリの例で出した、ユーザー情報の取得をAPIとして作ったとき、URIを割り当てると、

```
https://api.example.com/v1/users/me
```
となり、これが**エンドポイント**となる。

## 2.2.1 エンドポイントの基本的な設計
APIのエンドポイントはURIなので、通常のWebサイトと同じくURIの設計が重要になる。
良いURIの設計とは**覚えやすく、どんな機能を持つURIなのかがひと目でわかる**もの。
覚えやすくわかりやすいURIはざっくり以下のようなものを指す。

* 短く入力しやすいURI
* 人間が読んでも理解できるURI
* 大文字小文字が混在していないURI
* 改造しやすい(Hackableな)URI
* サーバ側のアーキテクチャが反映されていないURI
* ルールが統一されたURI


### 短く入力しやすいURI
読んで字のごとく、短くて入力しやすいURIはシンプルで覚えやすいため良い。

**Bad**
```
http://api.example.com/service/api/search


「api」や「search」というワードがあるので検索用のAPIということは伝わるが、
ホスト名とパス名に「api」が重複して、さらに「service」という同じ意味のような単語も入っている。
```

**Good**
```
http://api.example.com/search


検索用のAPIということは間違いなく伝わる。同じことを表しているなら短くてシンプルなほうが、
理解しやすく、覚えやすく、入力間違いも少ないはず。
```

### 人間が読んでも理解できるURI
検索APIのURIのように、**そのURIを見れば、それ以外の情報がなくてもそれが何を目的としたものなのかがある程度わかること**を意味する。

**Bad**
```
http://api.example.com/sv/u

「api」と入っているからAPIであることはわかるが、「sv」も「u」も意味がわからない。
短いURIを目指しているが、よりわかりにくくなっている。
```

理解しやすいURIにするための2つ目のポイントは**APIでよく使われている英単語を利用すること**。<br>
APIをわかりやすくするためには世界的な共通語である英語を使うのが適切。

例)ECサイトで何らかの製品情報を取得するためのAPI
```
http://api.example.com/products/12345

http://api.example.com/productos/12345

http://api.example.com/seihin/12345
```
製品という単語について、上のURIから順に英語、スペイン語、日本語になっている。わかりやすいのは一目瞭然で1つ目の英語を使ったURI。

しかし、英語を使えばいいというわけでもなく、一般的にAPIでよく使われる語彙を使っているかどうかでもわかりやすさは異なる。

例えば検索用のAPIでよく使われるのは「search」であって「find」ではない。<br>
「ある場所において探す(search)」と「あるものを探す(find)」というようにとる目的語が違う。

実際にどんな単語が使われているかは実際に他のAPIを見てみることが一番。<br>
1つだけ見るのではなく、複数のAPIを比較しながら見ると良い。

#### 理解しやすい3つ目のポイント。**スペルミスをしないこと**
* Referer: HTTPリクエストヘッダで存在するが、Referrerのスペルミス
* regist: 「登録する」で使われがちだが、実際にこの英単語は存在せず、「register」が正しい。registerは「登録」「登録する」と名詞、動詞どちらも使える。

**URIを設計する際はこうした英語っぽいけど英語にない言葉や和製英語は避ける。**

### 大文字小文字が混在していないURI
* URIは基本的にアルファベットの大文字と小文字を混在させず、**小文字のみを使用する**。
* 大文字が混ざった状態でアクセスされた際、エンドポイントを小文字として定義しているため、Not Foundエラーなどで返すケースが多い。

### 改造しやすい(Hackableな)URI
**URIを修正して別のURIにするのが容易であること**。

```
例)なんらかのアイテムを取得するエンドポイント
直感的に、IDが「12346」であるアイテムを取得するURIとわかり、
このIDを変えたら別の物が取得できると推測できる。
もちろん、ドキュメントに明記するべきだが、URIだけ見てわかると良い

http://api.example.com/v1/items/12346
```

**良くない例**

|  IDの範囲  |  エンドポイント  |
| ---- | ---- |
|  1 〜 300000  |  http://api.example.com/v1/items/alpha/:id  |
|  400001 〜 500000  |   http://api.example.com/v1/items/bata/:id  |
|  500001 〜 700000  |   http://api.example.com/v1/items/gamma/:id  |
|  700001 〜  |   http://api.example.com/v1/items/delta/:id  |

上記のように、IDによってエンドポイントが変わるようなURIは利用者側がいちいちドキュメントを見ながらIDによって場合分けをしないといけないので好ましくない。

こうしたサーバー側の都合はサーバー側で処理して、利用者側はサーバ側の都合を意識させないような設計にするべき。

### サーバ側のアーキテクチャが反映されていないURI
**サーバ側のアーキテクチャ**とは、サーバで使用しているソフトや言語、ディレクトリなどのシステム構成がどうなっているかということ。<br>

```
http://api.example.com/cgi-bin/get_user.php?user=100
```
上記のようなURIは、PHPで書かれていてCGIとして動作しているのがバレバレなので、<br>
攻撃される対象となってしまう。

どんな構成かわからないようなAPIを構築するべき。

### ルールが統一されたURI
Bad: ルールが統一されていないURI
```
friendが複数、単数バラバラで、IDがクエリパラメータとURIのパスになっており統一されていない。

# 友達の情報取得
http://api.example.com/friends?id=100

# メッセージの投稿
http://api.example.com/friend/100/message
```

Good: ルールが統一されているURI
```
friendがどちらも複数形、IDがどちらもパスに含まれていてわかりやすい。

# 友達の情報取得
http://api.example.com/friends/100

# メッセージの投稿
http://api.example.com/friends/100/message
```

## HTTPメソッドとエンドポイント
HTTPメソッドとはHTTP時のアクセス時に指定するものでGETやPOSTが有名。<br>
URIとメソッドの関係は操作するものと操作方法の関係と言える。<br>
URIがAPIにおいて「**操作する対象 = リソース**」だとすれば、HTTPメソッドは「**何をするか**」を表す。エンドポイントで取得できる情報がリソースで、メソッドはそのリソースを取得したいのか、修正したいのか、削除したいのか、そういった操作を指定する。

1つのURIのエンドポイントに異なるメソッドでアクセスすることで、リソースとそれをどう扱うかをキチンと分離することができる。

HTMLのFormではGETとPOSTしか扱うことができないが、HTTPの仕様には他にもメソッドがあり、Web APIではそれらをGETとPOST以外も利用するケースが多い。

|  メソッド名  |  説明  |
| ---- | ---- |
|  GET  |  リソースの取得  |
|  POST  |  リソースの新規登録  |
|  PUT  |  既存リソースの更新  |
|  DELETE  |  リソースの削除  |
|  PATCH  |  リソースの一部更新  |
|  HEAD  |  リソースのメタ情報の取得  |


## GETメソッド
ウェブへのアクセスに最も多く利用されていて、「情報の取得」を表す。<br>
URIで指定されたリソースを取得するために使う。

なので**GETでサーバ上のリソースが変更されることは基本的にありえない**。(既読システムなどは例外)<br>
削除処理をGETで実装していたためにGoogleのクローラに削除されてしまった例があるため、GETでサーバ側の情報を更新する処理を書くのはご法度。

## POSTメソッド
POSTメソッドは「リソースの更新」と思われがちだが、少し意味が異なる。

POSTメソッドは**指定したURIに属する新しいリソースを送信する**。つまり、「新しい情報を登録する」というのが本来の役割。

例)ユーザーを新規登録する、メッセージを新規投稿する

通常のWebページではFormでGETとPOSTしか使えないため、リソースの取得以外はPOSTでやりがちだけど、APIではきちんとメソッドで使い分ける。

## PUTメソッド

PUTは**更新したいリソースのURIそのものを指定し、その内容を書き換える**(リソースの修正)。

```
POSTでリソースを新規登録し、POSTによってできたリソースに対してPUTを指定して、リソースを修正/更新する。

POST: http//api.exmaple.com/v1/friends
PUT:  http//api.exmaple.com/v1/friends/12345
```

Web APIでは**データを修正知る場合はPUT、新しいリソースを生成する場合はPOST**を利用するのが一般的

## DELETEメソッド
DELETEメソッドはその名の通り、**リソースの削除**を行うメソッド。URIで指定されたリソースを削除する。

## PATCHメソッド
PATCHメソッドをPUTと同じくリソースの更新をするために利用するが、PUTが**送信したデータで既存リソースを置き換える**のに対して、PATCHは**既存リソースの一部だけを更新する**ときに利用する。

例えば、PUTで一部のデータを変更するのに毎回1MBのデータを送る必要があるAPIは、かなり非効率。PATCHで一部データだけで更新できるようなAPIを用意しておくと効率が良い。

## 2.4 APIのエンドポイント設計
以上の、URI設計とHTTPメソッドを踏まえて、2.1のSNSモバイルアプリケーションで必要なAPIを定義してみる。

以下、ユーザー情報の取得や変更に関するAPI設計

|  目的  |  エンドポイント  | メソッド
| ---- | ---- |  ---- |
|  ユーザー一覧取得  |  http://api.exmaple.com/v1/users  |GET|
|  ユーザーの新規登録  |  http://api.exmaple.com/v1/users  |POST|
|  特定ユーザーの情報の取得  |  http://api.exmaple.com/v1/users/:id  |GET|
|  ユーザーの情報更新  |  http://api.exmaple.com/v1/users/:id  |PUT/PATCH|
|  ユーザーの情報削除  |  http://api.exmaple.com/v1/users/:id  |DELETE|

上記のエンドポイントで以下のAPI機能カバーできる。
* ユーザー登録
* 自分の情報の取得
* 自分の情報の更新
* ユーザー情報の取得
* ユーザーの検索

APIとしては5つだが、エンドポイントは2つだけになっている。ユーザーの検索は一覧取得APIに対してクエリパラメータで絞り込みすることで実現させる。

「/users」「/users/:id」はそれぞれ「ユーザーの集合」「個々のユーザー」を表すエンドポイント。`:id`はユーザーIDを表すプレースホルダ。例えば、ユーザーIDが12345なら`/users/12345`となる。

**続いて、友達関連のAPI設計**

|  目的  |  エンドポイント  | メソッド|
| ---- | ---- |  ---- |
|  ユーザーの友達一覧取得  |  http://api.exmaple.com/v1/users/:id/friends |GET|
|  友達の追加  |  http://api.exmaple.com/v1/users/:id/friends  |POST|
|  友達の削除  |  http://api.exmaple.com/v1/users/:id/friends/:id  |DELETE|

これで対応できるAPIの機能は4つ
* 友達の追加
* 友達の削除
* 友達の一覧の取得
* 友達の検索

友達情報は特定のユーザーに紐づくものなので、`/users/:id/friends`のように個々のユーザーを表すURIとなる。

友達の削除する際、`/users/:id/friends/:id`とIDを2つ指定するが、<br>
このように「自分のID + 友達のID」としたほうが交友関係をユニークにできるし、利用者にわかりやすく、Hackableになりやすい。

**近況(タイムライン)に関するエンドポイント**

|  目的  |  エンドポイント  | メソッド|
| ---- | ---- |  ---- |
|  近況の編集  | http://api.exmaple.com/v1/updates/:id |PUT|
|  近況の削除  |  http://api.exmaple.com/v1/updates/:id  |DELETE|
|  近況の投稿  |  http://api.exmaple.com/v1/updates  |POST|
|  特定ユーザーの近況の取得  |  http://api.exmaple.com/v1/users/:id/updates  |GET|
|  友達の近況一覧の取得  |  http://api.exmaple.com/v1/users/:id/friends/updates  |GET|

「友達の近況一覧の取得」は自身に3人の友だちがいるなら、それら3人の近況をまとめて取得するイメージで、設計が難しいが、「友達一覧」を表すURIが`/users/:id/friends`となっているので、その配下に`updates`を付けるのがここでは自然。


## 2.4.1 リソースにアクセスするためのエンドポイントの設計の注意点
* 複数形の名詞を利用する
* 利用する単語に気をつける
* スペースやエンコードを必要とする文字を使わない
* 単語をつなげる必要がある場合はハイフンを利用する。

### 複数形の名詞を利用する
* データベースのテーブル名が複数形を用いるのが適切なのと同じで、「リソースの集合」を表すときは複数形を使うのが良い
    * ※ただ、`mouse`と`mice`のように形が変わるもの、`categories`のように語尾が変わるものがあるのでちゃんと調べること。
    * SNSのAPIに出てくる`updates`に関して、`update`は不可算名詞だが、ここでの文脈では近況の投稿1つ1つをupdateという単語を使って表しているので可算となり、`updates`になっている
* なぜ名詞か？ -> HTTPメソッドが動詞になっているため、リソースとHTTPメソッドの組み合わせがシンプルでわかりやすいから。
    * `get_person`のようにURIに動詞が含まれるものがあるが、getはHTTPメソッドで表現できるので、冗長となる。**URIは基本的にリソースを表すもの**なので極力、動詞を含めるのは避ける。


### 利用する単語に気をつける
searchは探す場所を目的語にとり、findは探すものを目的語にとる。<br>
基本APIではsearchが使われるのでsearchを使えば問題ない。

わからないときは他のAPIを見て参考にする。例えば、TODOリストサービスで各TODO項目はitemが使われ、写真はpictureではなくphotoが使われる。

### スペースやエンコードを必要とする文字を使わない
URIでは利用できない文字があり、そういった文字は**パーセントエンコーディング**と呼ばれる文字コードを`%`付きで表現した方法を利用する必要がある。(例、`%E3%81%81`など)<br>

**エンドポイントがどのようなものなのかがひと目でわからないので**APIのエンドポイントにはパーセントエンコーディングされた文字が入らないように設計する。

### 単語をつなげる必要がある場合はハイフンを使用する

ハイフンを使用する利用として、GoogleがSEO的に良い、ということしかないためAPIのURI設計において決定的な理由がないが、スネークケースやキャメルケースが単語のつなぎとみなさず、ひとつづきの単語としてみなしてしまったりするため、ポリシーが何もなければよく利用されているハイフンを使う。

ただし、最も良いのは**単語をつなぎ合わせる必要がないこと**。URIとしてわかりやすくするめ、`popular-users`などとせず、`users/popular`などパスで区切るのが良い。

## 2.5 検索とクエリパラメータ
ユーザー一覧を取得するエンドポイントがあったとして、ユーザーが1万人いた場合、明らかにデータサイズが大きすぎるので、そのエンドポイントを叩くと1万人すべて取得できるようにしてはいけない。
したがって、一度に取得可能な上限を決めて、ページングを行ってデータを取得できるように設計する必要がある。

通常、これはクエリパラメータで実現させる。

### 取得数と取得位置のクエリパラメータ
ページネーションを実装するには取得数と取得位置を指定する。<br>
Web APIでは取得数は`limit`と`count`、`per_page`、取得位置は`page`と`offset`、`cursor`あたりが一般的に利用される単語。

`page`と`offset`では微妙に異なり、`page`は`per_page`単位で1ページ、2ページと数えるが、`offset`ではアイテム単位で数える。

例)1ページ50アイテム存在する状態で、3ページ目から取得する場合

* `per_page=50&page=3`: 3ページ目から50個取得
* `limit=50&offset=100`: 3ページ目(アイテム100個飛ばして)50個取得

### 相対位置と絶対位置

#### 相対位置
pageやoffsetなどの相対的な取得位置でデータをを取得する方法は、データ量が増えるとパフォーマンスが悪くなり、更新頻度の高いデータにおいて、データに不整合が生じる可能性もある。(最初の20件を取得してから次の20件を取得する間にデータの更新が入ると、実際に取得したい情報と取得された情報にズレが出る)

#### 絶対位置
「先頭から数えて何件目」というような表示ではなく、指定したIDよりも前、あるいは指定した日時よりも前、といった方法で指定を行う。例えば、TwitterのAPIでは、`max_id`というパラメータがあり、指定したID以前のものを取得するようにできている。

### 絞り込みのためのパラメータ
くえりぱらめーたの名前には絞り込む要素名、値には絞り込む値を指定し、複数ある場合にはそれすべてを指定する。
```
http://api.linkedin.com/v1/people-search?first-name=Clair
```

検索するフィールドがほぼ1に決まるときは`q`というパラメータがよく使われる。

```
https://api.instagram.com/v1/users/search?q=jack
```

`q`はqueryの略で、`q`を使った場合、雰囲気的には部分一致も許可するイメージが強くなる。

```
http://api.exmaple.com/v1/users?name=ken : kenが完全一致

http://api.exmaple.com/v1/users?q=ken : ユーザー情報のどこかにkenを含むもの
```

## 2.5.5 クエリパラメータとパスの使い分け
クライアントが指定するパラメータはクエリパラメータとして入れるか、パスとして入れるかは以下の基準で判断する

* **一意なリソースを表すのに必要な情報かどうか**
* **省略可能かどうか**

URIがリソースを表すものなので、ユーザーIDの場合、ユーザーを一意に特定できるパラメータであるため、パスに入れるのが適切。<br>
アクセストークンなどは利用者の認可が目的でありリソースは無関係なのでクエリパラメータとして設計する。<br>
省略可能であればデフォルト値を使えばいいので、パスより、クエリパラメータのほうが適している。

```
http://api.exmaple.com/v1/users
http://api.exmaple.com/v1/users?since_id=12345
```