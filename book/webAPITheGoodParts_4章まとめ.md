# 4章 HTTPの仕様を最大限利用する


## ステータスコードを正しく使う

3章より、詳しくステータスコードについて見ていく。

### 200番台: 成功
指定したデータの取得に成功した、あるいはリクエストした処理が成功した場合には200番台のステータスコードを返す。

主な200番台のステータスコード
| ステータスコード  |  名前  | 説明 | 備考|
| ---- | ---- | ---- | ---- |
|  200  |  OK  |リクエストは成功した | |
|  201  |  Created  |リクエストが成功し、新しいリソースが作られた |Postなどで新規登録した際などに使う|
|  202  |  Accepted  |リクエストは成功した |リクエストした処理が非同期で行われ、<br>ひとまず処理は受け付けたことを意味する。|
|  204  |  No Content  |(返す)コンテンツなし |レスポンスが空のとき使用|


`204`はDELETEメソッドなどでデータを削除したときに返すことを想定しているステータスコード。<br>
ただ、`204`はレスポンスが空であるという情報は少なすぎて、結果をどう解釈していいかわからないところがあるので、あまり使うべきでないという意見もある。

本の筆者の見解では、PUTやPATCHは`200`とともに操作したデータを返し、DELETEの場合は`204`を返すというもの。こうしておけば返ってきたデータを見れば変更が正しく行われたことが理解できるから。

DELETEで削除をした場合について、削除しようとしているのはデータが不要であることが多く、削除データを受け取る処理が考えにくいので`204`で良い。


### 300番台 追加で処理が必要

主な300番台のステータスコード
| ステータスコード  |  名前  | 説明 | 備考|
| ---- | ---- | ---- | ---- |
|  300  |  Multiple Choices  |複数のリソースが存在する | |
|  301  |  Moved Permanently  |リソースは恒久的に移動した ||
|  302  |  Found  |リクエストしたリソースは一時的に移動している ||
|  303  |  See Other  |他を参照 ||
|  304  |  Not Modified  |前回から更新されていない ||
|  307  |  Temporary Redirect  |リクエストしたリソースは一時的に移動している ||

**300番台で最も利用されるのはリダイレクトに関するステータスコード**。<br>
`301`, `302`, `303`, `307`がリダイレクトに関するもの。リダイレクトの場合はレスポンスヘッダの`Location`にリダイレクト先のURIが含まれる。

ただ、ウェブサイトと違って、**Web APIの場合はリダイレクトをどのように行うかはクライアント側の実装によって異なるためAPIがリダイレクトが発生するようにするのはよろしくない。**また、アクセス回数も増えるのも良くない原因の1つ。<br>
もし、リダイレクトが起こりうるケースを実装する場合、ドキュメントに必ず記載する。

`304`(Not Modified)は前回データ取得から更新されていないことを表すステータスコード。`304`が返った場合はレスポンスボディは空になる。<br>


### 400番台 クライントのリクエストに問題があった場合
サーバ側に問題はないが、リクエストがおかしかったり、実行が許可されていなかったりと**クライアント側に問題がある場合に利用するステータスコード**。

主な400番台のステータスコード
| ステータスコード  |  名前  | 説明 | 備考|
| ---- | ---- | ---- | ---- |
|  400  |  Bad Request  |リクエストが正しくない |他の400番台では表現できないとき使う |
|  401  |  Unauthorized  |認証が必要 ||
|  403  |  Forbidden  |アクセスが禁止されている ||
|  404  |  Not Found  |指定したリソースが見つからない ||
|  405  |  Method Not Allowed  |指定されたメソッドは使うことができない |GETのAPIに対してPOST使ってきたときに返す|
|  406  |  Not Acceptable |Accept関連のヘッダに受理できない内容が含まれている ||
|  408  |  Request Timeout |リクエストが時間以内に完了しなかった ||
|  409  |  Confilict |リソースが矛盾した ||
|  410  |  Gone |指定したリソースは消滅した ||
|  413  |  Request Entity Too Large |リクエストボディが大きすぎる ||
|  414  |  Request-URI Too Long |リクエストされたURIが長すぎる ||
|  415  | Unsupported Media Type |サポートしていないメディアタイプが指定された ||
|  429  | Too Many Requests |リクエスト回数が多すぎる ||


* `401`(認証)と`403`(認可)は間違えやすい。**`401`はアクセスしてきた人が誰であるか識別できないとき**に返し、**`403`はアクセス者は識別できたけど、やろうとしてる操作が許可されていないとき**に返す。
* `404`: 単に404を返すだけでなく、何が存在しなかったのかを何らかの方法で返してあげる必要がある。
* `409`(Conflict): リソース競合が発生した際のエラー。IDなどユニークなキーを指定して登録をする際にすでに同じIDが登録済みであったときなどに返す。
* `410`(Gone): 404と同じくリソースが存在しないことを表現するが、410は「かつては存在したけど、今は存在しない」というときに返す。


### 500番台 サーバに問題があったとき
500番台はクライアント側ではなく、サーバ側に問題があったときに返すステータスコード。そのため500番台のエラーはログを取り、監視して管理者など通知が行くようにしなければいけない。

| ステータスコード  |  名前  | 説明 | 備考|
| ---- | ---- | ---- | ---- |
|  500  |  Internal Server Error |サーバ側でエラーが発生した | |
|  503  |  Service Unavailable  |サーバが一時的に停止している ||


## キャッシュとHTTPの仕様

ここでいうキャッシュは**サーバへのアクセスの頻度や通信量を減らすためにクライアント側で一度撮った情報を保存しておき、再度必要になったときにあらかじめ取得してあっと情報を利用すること**

メリット

* サーバへの通信を減らせる。
* ネットワークが切れた状態でもある程度サービスを継続できる。
* サーバへの通信回数、転送量を減らすことでユーザーの通信コストを下げることができる。
* サーバへのアクセス回数が減ることでサーバの維持費用を抑えられる。

キャッシュについて考える際は中継するプロキシサーバについても考える必要がある。<br>
プロキシサーバ自体がキャッシュする場合があるので実データが変更されたらそのキャッシュ情報を送らないと正しいデータがクライアントに届かなくなる可能性がある。


### Expiration Model (期限切れモデル)
HTTPのキャッシュについてはRFC7234で定義されており、キャッシュは**Expiration Model(期限切れモデル)** と **Validation Model(検証モデル)** という2つのタイプがある。

期限切れモデルは**あらかじめレスポンスデータに保存期限を決めて、期限が切れたら再度アクセスして取得を行う**。いつ期限が切れるかをサーバからのレスポンスに含めて返すことで実現する。レスポンスとして返す方法は2つあり、**Cache-Controlレスポンスヘッダを使う方法**、**Expiresレスポンスヘッダを使う方法**。

```
Expires: Fri, 01 Jan 2016 00:00:00 GMT
Cache-Control: max-age=3600
```
どちらを使うかはデータの性質によって異なる。<br>

* Expires: 期限切れを絶対時間で表す。
    * 天気APIなど、特定の日時に更新されることが予め分かっているデータに利用する。
    * 今後更新される可能性がないデータや静的データの場合には遠い将来の日時を指定することで一度取ったキャッシュデータをずっと保存しておくようにできる。**※ただし、HTTP1.1の仕様では1年以上未来の日付を送るべきではないとされているので1年以内にする。**
* Cache-Control: 現在時刻からの秒数で表す。
    * 「毎日何時」などの定期更新ではないものの更新頻度がある程度限られているものや、更新頻度は低くないものの、あまり頻繁にアクセスしてほしくない場合に利用する。(リアルタイム性が重要でない、サーバの負荷からアクセス頻度を下げてほしい場合)

ExpiresとCache-Controlが同時に利用された場合、より新しい仕様であるCache-Controlが優先される。


### Validation Model (検証モデル)
期限切れモデルがレスポンスを受け取ったときの情報だけを元にキャッシュの保持時間を決めていたのに対して、検証モデルは今持っているキャッシュが有効かどうかをサーバに問い合わせるというもの。<br>
期限が切れるまではネットワークにアクセスしない期限切れモデルとは異なり、キャッシュのチェックの際にもネットワークアクセスが発生する。<br>
例えば、100KBのデータを既にクライアント側にキャッシュしているのにまったく同じデータを再度ダウンロードするのと、データが更新されていなかった場合には「更新されていないよ」という情報だけを返すのとでは、転送データの量が変わり、大きなデータをやりとりするAPIであればあるほど、キャッシュの効果が高まる。

検証モデルでは、「今保持している情報が更新されていたら新しい情報をください」というような**条件付きリクエスト**をサーバに送信する。サーバは更新されていたときのみ、データを返し、更新されていないときは`304 Not Modified`を送ってクライアントに伝える。

条件付きリクエストの「クライアントが保持している情報の状態」は最終更新日付(Last-Modifiedヘッダ)とエンティティタグ(ETagヘッダ)のどちらかで表現できる。

サーバ側が返すレスポンス
```
Last-Modified: Tue, 01 Jul 2022 00:00:00 GMT
ETag: "ff39b31e285573ee373af0d492aca581"
```

* Last-Modified: 最終更新日付。そのデータが最後に更新された日付。
* ETag: 「ある特定のリソースのバージョンを表す識別子」の文字列。MD5など内容が変化すれば同時に変換する何らかの文字列。どうやって生成するかはサーバ側の実装による。

クライントは最終更新日付を使って条件付きリクエストを行う場合には`If-Modified-Since`ヘッダ、エンティティタグを使う場合には`If-None-Match`ヘッダを使う。

```
GET /v1/users/12345
If-Modified-Since: Tue, 01 2022 00:00:00 GMT
```

```
GET /v1/users/12345
If-None-Match: "ff39b31e285573ee373af0d492aca581"
```


高頻度でデータが変わったりする場合など、キャッシュさせたくないときは`Cache-Control: no-cache`を使用して明示的にキャッシュさせないようにできる。※**`no-cache`は厳密にはキャッシュをしないという指定ではなく、最低限「検証モデルを用いて必ず検証を行う」必要があることを意味する。**


## メディアタイプの指定

HTTPのリクエスト、レスポンスでは送信するデータ本体の形式を表すためにメディアタイプを指定する必要がある。メディアタイプはどんなデータ形式かなのかを示し、`Content-Type`というヘッダを利用する。

メディアタイプは`トップレベルタイプ名 / サブタイプ名 [; パラメータ]`で表す

* トップレベルタイプ名: データ形式を大別してテキスト、画像、動画などカテゴリ
* サブタイプ名: より具体的なデータ形式

```
Content-Type: application/json
Content-Type: image/png

それぞれ、jsonとpng画像であることを表す
```
代表的なメディアタイプ

| メディアタイプ  |  データ形式  | 
| ---- | ---- |
|  `text/plan ` |  プレーンテキスト |
|  `text/html`  |  HTML文書  |
|  `application/xml`  |  XML文書  |
|  `text/css`  |  css文書  |
|  `application/javascript`  |  JavaScript  |
|  `application/json`  |  JSON  |
|  `application/octet-stream`  |  バイナリデータ  |
|  `application/zip`  |  zipファイル  |
|  `image/jpeg`  |  JPEG画像  |
|  `image/png`  |  PNG画像  |
|  `image/svg+xml`  |  SVG画像  |
|  `multipart/form-data`  |  複数のデータで構成されるウェブフォームデータ  |
|  `video/mp4`  |  mp4動画ファイル  |
|  `application/vnd.ms-excel`  |  Excelファイル  |


* クライアント側は`Content-Type`ヘッダのメディアタイプを使用する場合があるので、APIがメディアタイプを返してあげないとクライアント側は正しくデータを読み取ることができない。